// TO DO://    only change the pre-hint part//    accept returns in the "Replace" field (instead of requiring control-return)//    pre-cs2 compatibility (and do a compatibility version check with error message)//    have new groups appear below instead of above original//    allow multi phrase find and replace with separator, as in find "my;;truck" replace "your;;car"  so "my snazzy truck" become "your snazzy car", even if "my" and "truck" are on diff layers./*@@@BUILDINFO@@@ Smart Group Dupe.jsx 1.0*//*// BEGIN__HARVEST_EXCEPTION_ZSTRING<javascriptresource><name>$$$/JavaScripts/SmartGroupDupe/Menu=SiteGrinder Smart Group Duplicator...</name><about>$$$/JavaScripts/SmartGroupDupe/About=Smart Group Dupe for SiteGrinder 3</about><category>sitegrinder</category><enableinfo>true</enableinfo></javascriptresource>// END__HARVEST_EXCEPTION_ZSTRING*/#target photoshop// enable double clicking from the Macintosh Finder or the Windows Explorer// debug level: 0-2 (0:disable, 1:break on error, 2:break at beginning)// $.level = 0;// debugger; // launch debugger on next line// on localized builds we pull the $$$/Strings from a .dat file, see documentation for more details$.localize = true;//=================================================================// Globals//=================================================================// UI strings to be localized// the drop down list indexes for file type// ok and cancel buttonvar runButtonID = 1;var cancelButtonID = 2;var multiSearchDelimiter = '||';///////////////////////////////////////////////////////////////////////////////// Dispatch///////////////////////////////////////////////////////////////////////////////main();///////////////////////////////////////////////////////////////////////////////// Functions//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Function: main// Usage: the core routine for this script// Input: <none>// Return: <none>///////////////////////////////////////////////////////////////////////////////function main() {//	app.Preferences.TypeUnits = 2;//	var l = app.activeDocument.activeLayer.textItem.position;	//app.preferences.typeUnits = TypeUnits.POINTS; //	app.preferences.rulerUnits = Units.PIXELS;//	l = app.activeDocument.activeLayer.textItem.position;//	var p = getTextPositionPixels(app.activeDocument.activeLayer);//	var t = l;//	offSetTypeLayerPixels(app.activeDocument.activeLayer,0,30); //	offSetArtLayerPixels( app.activeDocument.activeLayer,100,100);        if ( app.documents.length <= 0 ) {        if ( DialogModes.NO != app.playbackDisplayDialogs ) {            alert( "You must have an open document" );        }    	return 'cancel'; // quit, returning 'cancel' (dont localize) makes the actions palette not record our script    }    var smartDupeInfo = new Object();	    	if (cancelButtonID == settingDialog(smartDupeInfo)) {	    	return 'cancel'; // quit, returning 'cancel' (dont localize) makes the actions palette not record our script	    }       	        try {        //var docName = app.activeDocument.name;  // save the app.activeDocument name before duplicate.           // app.activeDocument = app.documents[docName];		   smartDuplicate(smartDupeInfo);           // docRef = app.activeDocument;			}    catch (e) {        //if ( DialogModes.NO != app.playbackDisplayDialogs ) {          //  alert(e);        //}    	//return 'cancel'; // quit, returning 'cancel' (dont localize) makes the actions palette not record our script    }	}function offSetTypeLayerPixels(lay,xo,yo) {	    if(lay.textItem) {			var saveRuler = app.preferences.rulerUnits;			app.preferences.rulerUnits = Units.PIXELS;			var curPointPixels = getTextPositionPixels(lay);			if(curPointPixels != null && curPointPixels.x && curPointPixels.y) {				var newX = new UnitValue( ( curPointPixels.x + xo ) , 'px' ); 				var newY = new UnitValue( ( curPointPixels.y + yo ) , 'px' ); 				lay.textItem.position = [newX,newY];			}			app.preferences.rulerUnits = saveRuler;		}}function translatePixels(lay,xo,yo) {	    if(lay.translate) {						var saveRuler = app.preferences.rulerUnits;			app.preferences.rulerUnits = Units.PIXELS;			var uxo = new UnitValue( ( xo ) , 'px' ); 			var uyo = new UnitValue( ( yo ) , 'px' ); 						lay.translate( uxo, uyo, OffsetUndefinedAreas.WRAPAROUND) ;			app.preferences.rulerUnits = saveRuler;		}}function getTextPositionPixels(lay) {		var saveRuler = app.preferences.rulerUnits;		var pt = null;		app.preferences.rulerUnits = Units.PIXELS;	     if(lay.textItem) {			pt = { };			pt.x = lay.textItem.position[0].value;			pt.y = lay.textItem.position[1].value;		}		app.preferences.rulerUnits = saveRuler;		return pt;	}function smartDuplicate(info) {		var docRef = app.activeDocument;	//var layerRef = docRef.artLayers[0].duplicate();	//layerRef.moveToEnd(layerSetRef);		//alert(docRef.activeLayer.name);		//var groupLayers = docRef.activeLayer.layers;	//var len = groupLayers.length;	//if(len != 1) { alert("Please select one layer or one layer group"); return; }	//var layerSetRef = docRef.layerSets.add();	//docRef.activeLayers.add(docRef.activeLayer.duplicate());	//renameSetLayers(docRef.activeLayer.duplicate(),info.find,info.replace);	info.origSet = docRef.activeLayer;	iterateLayers(docRef.activeLayer,collectLayerObjs,info);	info.curXLoc = 0;	info.curYLoc = 0;	//var origName = docRef.activeLayer.name;	//alert(docRef.activeLayer.artLayers.length);	var newNameArray = info.replace.split('\n');	for(var curNewSet = 0; curNewSet< newNameArray.length; curNewSet++) {		if(newNameArray[curNewSet] !="") {			info.curXLoc += info.xOff;			info.curYLoc += info.yOff;			var dup = info.origSet.duplicate();			if(info.curXLoc!=0 || info.curYLoc!=0) { translatePixels(dup, info.curXLoc, info.curYLoc); }			//dup.name = origName;			info.iterationIndexUtilVar = 0;			info.replace = newNameArray[curNewSet];			iterateLayers(dup,renameSetLayer,info);			info.iterationIndexUtilVar = 0;		}	}}function iterateLayers(set, layFunc,varObj) {	if(typeof(varObj.iterationIndexUtilVar) == 'undefined') { varObj.iterationIndexUtilVar = 0; }		layFunc(set,varObj);	varObj.iterationIndexUtilVar++;	if(typeof(set.artLayers) != 'undefined') {		for( var i = 0; i < set.artLayers.length; i++) 		{			layFunc(set.artLayers[i],varObj);			varObj.iterationIndexUtilVar++;		 }		for( var i = 0; i < set.layerSets.length; i++) 				{					 iterateLayers(set.layerSets[i], layFunc, varObj);  // recursive call					 layFunc(set.layerSets[i],varObj);					 varObj.iterationIndexUtilVar++;				}		}}function collectLayerObjs(lay,vars) {	if(typeof(vars.layCollection) == 'undefined') { vars.layCollection = new Array(); }	vars.layCollection.push(lay);}// This version takes delimited text for multi item find and replace// vars.find = "find1||find2"// vars.replace = "replace1||replace2"function renameSetLayer(lay,vars) {	if(!lay.isBackgroundLayer) {		var findArray = vars.find.split(multiSearchDelimiter);		var replaceArray = vars.replace.split(multiSearchDelimiter);		if(findArray.length != replaceArray.length) { return; }  // Pass the buck if find words list isn't the same length as replace words list		var fixTextContents = "";		lay.name = vars.layCollection[vars.iterationIndexUtilVar].name;		if(lay.kind == LayerKind.TEXT && vars.replaceTextContents) { fixTextContents = lay.textItem.contents; }		for(var curSearchNum = 0; curSearchNum < findArray.length; curSearchNum++) {			var find = findArray[curSearchNum];			var replace = replaceArray[curSearchNum];			if(vars.caseSensitive) { lay.name= lay.name.replace(find,replace); }			else { lay.name = replaceNoCase(lay.name, find, replace);}			if(lay.kind == LayerKind.TEXT && vars.replaceTextContents) { 					//alert('find ' + find + ' replace with: ' + replace + ' in text: ' + fixTextContents);					if(vars.caseSensitive) { fixTextContents = fixTextContents.replace(find,replace); }					else { fixTextContents = replaceNoCase(fixTextContents, find, replace); }			}		}		if(lay.kind == LayerKind.TEXT && vars.replaceTextContents) { lay.textItem.contents = fixTextContents; }	}}/*// This version takes nondelimited strings for single word/phrase find and replacefunction renameSetLayer(lay,vars) {	if(!lay.isBackgroundLayer) {		lay.name = vars.layCollection[vars.iterationIndexUtilVar].name;		if(vars.caseSensitive) { lay.name= lay.name.replace(vars.find,vars.replace); }		else { lay.name = replaceNoCase(lay.name, vars.find, vars.replace);}		if(lay.kind == LayerKind.TEXT && vars.replaceTextContents) { 				if(vars.caseSensitive) { lay.textItem.contents = lay.textItem.contents.replace(vars.find,vars.replace); }				else { lay.textItem.contents = replaceNoCase(lay.textItem.contents, vars.find, vars.replace); };		}	}}*/function replaceNoCase(findIn, find, replace) {	//alert(findIn + " " + find + " " + replace);	var findInLow = findIn.toLowerCase();	var findLow = find.toLowerCase();	var loc = findInLow.indexOf(findLow);	if(loc >= 0) {		return findIn.substring(0,loc) + replace + findIn.substring(loc+find.length,findIn.length);	}	else return findIn;}/*function goodrenameSetLayers(set,find,replace) {	//alert("finding " + find + " replacing with " + replace);	set.name = set.name.replace(find,replace);    for( var i = 0; i < set.artLayers.length; i++) 	{        var origLayer = set.artLayers[i];		if(!origLayer.isBackgroundLayer)		{			var layerName = origLayer.name;  // store layer name before change doc			var newName = layerName.replace(find,replace);			origLayer.name=newName;		}    }	for( var i = 0; i < set.layerSets.length; i++) 			{				 renameSetLayers(set.layerSets[i], find,replace);  // recursive call				 set.layerSets[i].name = set.layerSets[i].name.replace(find,replace);			}	}*////////////////////////////////////////////////////////////////////////////////// Function: settingDialog// Usage: pop the ui and get user settings// Input: exportInfo object containing our parameters// Return: on ok, the dialog info is set to the exportInfo object///////////////////////////////////////////////////////////////////////////////function settingDialog(exportInfo){    dlgMain = new Window("dialog", "Smart Layer Group Duplicator for SiteGrinder 3");        // match our dialog background color to the host application//	var brush = dlgMain.graphics.newBrush(dlgMain.graphics.BrushType.THEME_COLOR, "appDialogBackground");    // This brush stuff screws up on C3  //  dlgMain.graphics.backgroundColor = brush;    //dlgMain.graphics.disabledBackgroundColor = brush;	dlgMain.orientation = 'column';	dlgMain.alignChildren = 'left';	    dlgMain.etHelp = dlgMain.add("statictext", undefined, "Duplicates layers and groups replacing words in the layer names and text contents", {multiline:true});    dlgMain.etHelp.alignment = 'fill';		// -- top of the dialog, first line    dlgMain.add("statictext", undefined, "Find:");    dlgMain.etFind = dlgMain.add("edittext", undefined, "");	dlgMain.etFind.alignment = 'fill';    dlgMain.etFind.width = 300;	dlgMain.replaceTextContents = dlgMain.add("checkbox",undefined,"Replace in text layer contents");	dlgMain.replaceTextContents.value = false;	dlgMain.caseSensitive = dlgMain.add("checkbox",undefined,"Case sensitive");	dlgMain.caseSensitive.value = false;	    dlgMain.add("statictext", undefined, "Replace with: \n(Enter one word on each line for as many group dulications as you desire. Press control-return to add additional lines)",{multiline:true});    dlgMain.etReplace = dlgMain.add("edittext", [115,45,315,145], "", {multiline:true});  // using a bunch of \n here screws up CS2 windows display	dlgMain.etReplace.alignment = 'fill';	//dlgMain.etReplace.width = 300;	//dlgMain.etReplace.height = 300;  	// -- top of the dialog, first line    dlgMain.add("statictext", undefined, "Horizontal Offset:");    dlgMain.xoff = dlgMain.add("edittext", undefined, "0");	dlgMain.xoff.alignment = 'fill';    dlgMain.add("statictext", undefined, "Vertical Offset:");    dlgMain.yoff = dlgMain.add("edittext", undefined, "0");	dlgMain.yoff.alignment = 'fill';  	dlgMain.btnRun = dlgMain.add("button", undefined, "Run" );    dlgMain.btnRun.onClick = function() {		// check if the setting is properly		/*var destination = dlgMain.etDestination.text;		if (destination.length == 0) {	        alert(strAlertSpecifyDestination);			return;		}		var testFolder = new Folder(destination);		if (!testFolder.exists) {	        alert(strAlertDestinationNotExist);			return;		}*/		dlgMain.close(runButtonID);	}	dlgMain.btnCancel = dlgMain.add("button", undefined, "Cancel" );    dlgMain.btnCancel.onClick = function() { 		dlgMain.close(cancelButtonID); 	}	//dlgMain.defaultElement = dlgMain.btnRun;	dlgMain.cancelElement = dlgMain.btnCancel;    // in case we double clicked the file    app.bringToFront();    dlgMain.center();        var result = dlgMain.show();        if (cancelButtonID == result) {		return result;  // close to quit	}    // get setting from dialog    exportInfo.find = dlgMain.etFind.text;    exportInfo.replace = dlgMain.etReplace.text;	if(isNaN(parseFloat(dlgMain.xoff.text))) { exportInfo.xOff = 0; }	else { exportInfo.xOff = parseFloat(dlgMain.xoff.text); }	if(isNaN(parseFloat(dlgMain.yoff.text))) { exportInfo.yOff = 0; }	else { exportInfo.yOff = parseFloat(dlgMain.yoff.text); }	exportInfo.replaceTextContents = dlgMain.replaceTextContents.value;	exportInfo.caseSensitive = dlgMain.caseSensitive.value;    return result;}///////////////////////////////////////////////////////////////////////////////// Function: zeroSuppress// Usage: return a string padded to digit(s)// Input: num to convert, digit count needed// Return: string padded to digit length///////////////////////////////////////////////////////////////////////////////function zeroSuppress (num, digit){    var tmp = num.toString();    while (tmp.length < digit) {		tmp = "0" + tmp;	}    return tmp;}///////////////////////////////////////////////////////////////////////////////// Function: objectToDescriptor// Usage: create an ActionDescriptor from a JavaScript Object// Input: JavaScript Object (o)//        object unique string (s)//        Pre process converter (f)// Return: ActionDescriptor// NOTE: Only boolean, string, number and UnitValue are supported, use a pre processor//       to convert (f) other types to one of these forms.// REUSE: This routine is used in other scripts. Please update those if you //        modify. I am not using include or eval statements as I want these //        scripts self contained.///////////////////////////////////////////////////////////////////////////////function objectToDescriptor (o, s, f) {	if (undefined != f) {		o = f(o);	}	var d = new ActionDescriptor;	var l = o.reflect.properties.length;	d.putString( app.charIDToTypeID( 'Msge' ), s );	for (var i = 0; i < l; i++ ) {		var k = o.reflect.properties[i].toString();		if (k == "__proto__" || k == "__count__" || k == "__class__" || k == "reflect")			continue;		var v = o[ k ];		k = app.stringIDToTypeID(k);		switch ( typeof(v) ) {			case "boolean":				d.putBoolean(k, v);				break;			case "string":				d.putString(k, v);				break;			case "number":				d.putDouble(k, v);				break;			default:			{				if ( v instanceof UnitValue ) {					var uc = new Object;					uc["px"] = charIDToTypeID("#Rlt"); // unitDistance					uc["%"] = charIDToTypeID("#Prc"); // unitPercent					d.putUnitDouble(k, uc[v.type], v.value);				} else {					throw( new Error("Unsupported type in objectToDescriptor " + typeof(v) ) );				}			}		}	}    return d;}///////////////////////////////////////////////////////////////////////////////// Function: descriptorToObject// Usage: update a JavaScript Object from an ActionDescriptor// Input: JavaScript Object (o), current object to update (output)//        Photoshop ActionDescriptor (d), descriptor to pull new params for object from//        object unique string (s)//        JavaScript Function (f), post process converter utility to convert// Return: Nothing, update is applied to passed in JavaScript Object (o)// NOTE: Only boolean, string, number and UnitValue are supported, use a post processor//       to convert (f) other types to one of these forms.// REUSE: This routine is used in other scripts. Please update those if you //        modify. I am not using include or eval statements as I want these //        scripts self contained.///////////////////////////////////////////////////////////////////////////////function descriptorToObject (o, d, s, f) {	var l = d.count;	if (l) {	    var keyMessage = app.charIDToTypeID( 'Msge' );        if ( d.hasKey(keyMessage) && ( s != d.getString(keyMessage) )) return;	}	for (var i = 0; i < l; i++ ) {		var k = d.getKey(i); // i + 1 ?		var t = d.getType(k);		strk = app.typeIDToStringID(k);		switch (t) {			case DescValueType.BOOLEANTYPE:				o[strk] = d.getBoolean(k);				break;			case DescValueType.STRINGTYPE:				o[strk] = d.getString(k);				break;			case DescValueType.DOUBLETYPE:				o[strk] = d.getDouble(k);				break;			case DescValueType.UNITDOUBLE:				{				var uc = new Object;				uc[charIDToTypeID("#Rlt")] = "px"; // unitDistance				uc[charIDToTypeID("#Prc")] = "%"; // unitPercent				uc[charIDToTypeID("#Pxl")] = "px"; // unitPixels				var ut = d.getUnitDoubleType(k);				var uv = d.getUnitDoubleValue(k);				o[strk] = new UnitValue( uv, uc[ut] );				}				break;			case DescValueType.INTEGERTYPE:			case DescValueType.ALIASTYPE:			case DescValueType.CLASSTYPE:			case DescValueType.ENUMERATEDTYPE:			case DescValueType.LISTTYPE:			case DescValueType.OBJECTTYPE:			case DescValueType.RAWTYPE:			case DescValueType.REFERENCETYPE:			default:				throw( new Error("Unsupported type in descriptorToObject " + t ) );		}	}	if (undefined != f) {		o = f(o);	}}///////////////////////////////////////////////////////////////////////////////// Function: preProcessExportInfo// Usage: convert Photoshop enums to strings for storage// Input: JavaScript Object of my params for this script// Return: JavaScript Object with objects converted for storage///////////////////////////////////////////////////////////////////////////////function preProcessExportInfo(o) {	o.tiffCompression = o.tiffCompression.toString();	o.pdfEncoding = o.pdfEncoding.toString();	o.targaDepth = o.targaDepth.toString();	o.bmpDepth = o.bmpDepth.toString();	return o;}///////////////////////////////////////////////////////////////////////////////// Function: postProcessExportInfo// Usage: convert strings from storage to Photoshop enums// Input: JavaScript Object of my params in string form// Return: JavaScript Object with objects in enum form///////////////////////////////////////////////////////////////////////////////function postProcessExportInfo(o) {	o.tiffCompression = eval(o.tiffCompression);	o.pdfEncoding = eval(o.pdfEncoding);	o.targaDepth = eval(o.targaDepth);	o.bmpDepth = eval(o.bmpDepth);	return o;}///////////////////////////////////////////////////////////////////////////// Function: StrToIntWithDefault// Usage: convert a string to a number, first stripping all characters// Input: string and a default number// Return: a number///////////////////////////////////////////////////////////////////////////function StrToIntWithDefault( s, n ) {    var onlyNumbers = /[^0-9]/g;    var t = s.replace( onlyNumbers, "" );	t = parseInt( t );	if ( ! isNaN( t ) ) {        n = t;    }    return n;}///////////////////////////////////////////////////////////////////////////////// Function: folderExists// Usage: see if the string passed in is a valid folder ask to create if not// Input: string of the folder in question// Return: true if folder exists or was created successfully///////////////////////////////////////////////////////////////////////////////function folderExists( folderAsString ) {	var f = Folder(folderAsString);	if (f.exists) return true;	if (DialogModes.NO == app.playbackDisplayDialogs) return false;	if (confirm(strCreateFolder + folderAsString)) {		if (f.create()) {			return true;		} else {			alert(strCouldNotCreate);		}	}	return false;}///////////////////////////////////////////////////////////////////////////////// Function: NumericEditKeyboardHandler// Usage: Do not allow anything except for numbers 0-9// Input: ScriptUI keydown event// Return: <nothing> key is rejected and beep is sounded if invalid///////////////////////////////////////////////////////////////////////////////function NumericEditKeyboardHandler (event) {    try {        var keyIsOK = KeyIsNumeric (event) || 		              KeyIsDelete (event) || 					  KeyIsLRArrow (event) ||					  KeyIsTabEnterEscape (event);					          if (! keyIsOK) {            //    Bad input: tell ScriptUI not to accept the keydown event            event.preventDefault();            /*    Notify user of invalid input: make sure NOT                to put up an alert dialog or do anything which                requires user interaction, because that                interferes with preventing the 'default'                action for the keydown event */            app.beep();        }    }    catch (e) {        ; // alert ("Ack! bug in NumericEditKeyboardHandler: " + e);    }}//    key identifier functionsfunction KeyHasModifier (event) {    return event.shiftKey || event.ctrlKey || event.altKey || event.metaKey;}function KeyIsNumeric (event) {    return  (event.keyName >= '0') && (event.keyName <= '9') && ! KeyHasModifier (event);}function KeyIsDelete (event) {    //    Shift-delete is ok    return (event.keyName == 'Backspace') && ! (event.ctrlKey);}function KeyIsLRArrow (event) {    return ((event.keyName == 'Left') || (event.keyName == 'Right')) && ! (event.altKey || event.metaKey);}function KeyIsTabEnterEscape (event) {	return event.keyName == 'Tab' || event.keyName == 'Enter' || event.keyName == 'Escape';}// End Layer Comps To Files.jsx